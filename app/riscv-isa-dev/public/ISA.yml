RV32I: &id_rv32i
  meta:
    version: "2.1"
    desc: "base integer instruction set"
  ADDI:
    asm: addi rd, rs1, imm12
    desc: ADDI adds the sign-extended 12-bit immediate to register rs1. Arithmetic overflow is ignored and the result is simply the low XLEN bits of the result.
    code: |
      imm = sign_extend(imm12)
      rd = rs1 + imm
    pseudos:
      MV:
        asm: mv rd, rs1
        real: addi rd, rs1, 0
        desc: MV copies the value in register rs1 to register rd.
      NOP:
        asm: nop
        real: addi x0, x0, 0
        desc: The NOP instruction does not change any architecturally visible state, except for advancing the pc and incrementing any applicable performance counters.
  SLTI:
    asm: slti rd, rs1, imm12
    desc: SLTI (set less than immediate) places the value 1 in register rd if register rs1 is less than the sign-extended 12-bit immediate when both are treated as signed numbers, else 0 is written to rd.
    code: |
      rd = signed(rs1) < imm12 ? 1 : 0
  SLTIU:
    asm: sltiu rd, rs1, imm12
    desc: SLTIU is similar with SLTI but compares the values as unsigned numbers (i.e., the immediate is first sign-extended to XLEN bits then treated as an unsigned number).
    code: |
      imm = sign_extend(imm12)
      rd = unsigned(rs1) < unsigned(imm) ? 1 : 0
    pseudos:
      SEQZ:
        asm: seqz rd, rs1
        real: sltiu rd, rs1, 1
        desc: SEQZ (set equal zero) place
        code: |
          rd = rs1 == 0 ? 1 : 0
  ANDI:
    asm: andi rd, rs1, imm12
    desc: ANDI are logical operations that perform bitwise AND on register rs1 and the sign-extended 12-bit immediate and place the result in rd.
    code: |
      imm = sign_extend(imm12)
      rd = rs1 & imm
  ORI:
    asm: ori rd, rs1, imm12
    desc: ORI are logical operations that perform bitwise OR on register rs1 and the sign-extended 12-bit immediate and place the result in rd.
    code: |
      imm = sign_extend(imm12)
      rd = rs1 | imm
  XORI:
    asm: xori rd, rs1, imm12
    desc: XORI are logical operations that perform bitwise XOR on register rs1 and the sign-extended 12-bit immediate and place the result in rd.
    code: |
      imm = sign_extend(imm12)
      rd = rs1 ^ imm
    pseudos:
      NOT:
        asm: not rd, rs1
        real: xori rd, rs1, -1
        desc: NOT performs a bitwise logical inversion of register rs1
        code: |
          rd = ! rs1
  SLLI:
    asm: slli rd, rs1, uimm5
    desc: SLLI is a logical left shift (zeros are shifted into the lower bits).
  SRLI:
    asm: srli rd, rs1, uimm5
    desc: SRLI is a logical right shift (zeros are shifted into the upper bits).
  SRAI:
    asm: srai rd, rs1, uimm5
    desc: SRAI is an arithmetic right shift (the original sign bit is copied into the vacated upper bits).
  LUI:
    asm: lui rd, imm20
    desc: LUI (load upper immediate) is used to build 32-bit constants and uses the U-type format. LUI places the 32-bit U-immediate value into the destination register rd, filling in the lowest 12 bits with zeros.
    code: |
      imm = imm20 << 12
      rd = imm
  AUIPC:
    asm: auipc rd, imm20
    desc: AUIPC (add upper immediate to pc) is used to build pc-relative addresses and uses the U-type format. AUIPC forms a 32-bit offset from the U-immediate, filling in the lowest 12 bits with zeros, adds this offset to the address of the AUIPC instruction, then places the result in register rd.
    code: |
      imm = imm20 << 12
      rd = pc + imm
  ADD:
    asm: add rd, rs1, rs2
    desc: ADD performs the addition of rs1 and rs2. Overflows are ignored and the low XLEN bits of results are written to the destination rd.
    code: |
      rd = rs1 + rs2
  SUB:
    asm: sub rd, rs1, rs2
    desc: SUB performs the subtraction of rs2 from rs1. Overflows are ignored and the low XLEN bits of results are written to the destination rd.
    code: |
      rd = rs1 - rs2
  SLT:
    asm: slt rd, rs1, rs2
    desc: SLT perform signed compares, writing 1 to rd if rs1 < rs2, 0 otherwise.
    code: |
      rd = rs1 < rs2 ? 1 : 0
  SLTU:
    asm: sltu rd, rs1, rs2
    desc: SLTU perform unsigned compares, writing 1 to rd if rs1 < rs2, 0 otherwise.
    code: |
      rd = unsigned(rs1) < unsigned(rs2) ? 1 : 0
  AND:
    asm: and rd, rs1, rs2
    desc: AND are logical operations that perform bitwise AND on register rs1 and rs2 and place the result in rd.
    code: |
      rd = rs1 & rs2
  OR:
    asm: or rd, rs1, rs2
    desc: OR are logical operations that perform bitwise OR on register rs1 and rs2 and place the result in rd.
    code: |
      rd = rs1 | rs2
  XOR:
    asm: xor rd, rs1, rs2
    desc: XOR are logical operations that perform bitwise XOR on register rs1 and rs2 and place the result in rd.
    code: |
      rd = rs1 ^ rs2
  SLL:
    asm: sll rd, rs1, rs2
    desc: SLL perform logical left shifts on the value in register rs1 by the shift amount held in the lower 5 bits of register rs2.
    code: |
      uimm5 = uimm5_low(rs2)
      rd = rs1 << uimm5
  SRL:
    asm: srl rd, rs1, rs2
    desc: SRL perform logical right shifts on the value in register rs1 by the shift amount held in the lower 5 bits of register rs2.
    code: |
      uimm5 = uimm5_low(rs2)
      rd = unsigned(rs1) >> uimm5
  SRA:
    asm: sra rd, rs1, rs2
    desc: SRA perform arithmetic right shifts on the value in register rs1 by the shift amount held in the lower 5 bits of register rs2.
    code: |
      uimm5 = uimm5_low(rs2)
      rd = signed(rs1) >> uimm5
  JAL:
    asm: jal rd, imm20
    desc: The jump and link (JAL) instruction uses the J-type format, where the imm20 encodes a signed offset in multiples of 2 bytes. The offset is sign-extended and added to the address of the jump instruction to form the jump target address. Jumps can therefore target a ±1 MiB range. JAL stores the address of the instruction following the jump (pc+4) into register rd. The standard software calling convention uses x1 as the return address register and x5 as an alternate link register.
    code: |
      rd = pc + 4
      goto pc + (imm20 << 1)
    pseudos:
      J:
        asm: j imm20
        real: jal x0, imm20
        desc: Plain unconditional jumps.
        code: |
          goto pc + (imm20 << 1)
  JALR:
    asm: jalr rd, rs1, imm12
    desc: The target address is obtained by adding the sign-extended 12-bit imm12 to the register rs1, then setting the least-significant bit of the result to zero. The address of the instruction following the jump (pc+4) is written to register rd. Register x0 can be used as the destination if the result is not required. The JALR instruction was defined to enable a two-instruction sequence to jump anywhere in a 32-bit absolute address range. A LUI instruction can first load rs1 with the upper 20 bits of a target address, then JALR can add in the lower bits. Similarly, AUIPC then JALR can jump anywhere in a 32-bit pc-relative address range.
    code: |
      rd = pc + 4
      goto rs1 + imm12
  # 2.5 Control Transfer Instructions
  # Conditional Branches
  BEQ:
    asm: beq rs1, rs2, imm12
    desc: BEQ take the branch if registers rs1 and rs2 are equal. The 12-bit B-immediate encodes signed offsets in multiples of 2 bytes. The offset is sign-extended and added to the address of the branch instruction to give the target address.
    code: |
      if (rs1 == rs2) {
        next_pc = current_pc + (imm12 << 1)
      } else {
        next_pc = current_pc + 4
      }
  BNE:
    asm: bne rs1, rs2, imm12
    desc: BNE take the branch if registers rs1 and rs2 are unequal. The 12-bit B-immediate encodes signed offsets in multiples of 2 bytes. The offset is sign-extended and added to the address of the branch instruction to give the target address.
    code: |
      if (rs1 != rs2) {
        next_pc = current_pc + (imm12 << 1)
      } else {
        next_pc = current_pc + 4
      }
  BLT:
    asm: blt rs1, rs2, imm12
    desc: BLT take the branch if rs1 is less than rs2, using signed comparison.
    code: |
      if (rs1 < rs2) {
        next_pc = current_pc + (imm12 << 1)
      } else {
        next_pc = current_pc + 4
      }
    pseudos:
      BGT:
        asm: bgt rs1, rs2, imm12
        real: blt rs2, rs1, imm12
        desc: BGT take the branch if rs1 is greater than rs2, using signed comparison.
        code: |
          if (rs1 > rs2) {
            next_pc = current_pc + (imm12 << 1)
          } else {
            next_pc = current_pc + 4
          }
  BLTU:
    asm: bltu rs1, rs2, imm12
    desc: BLTU take the branch if rs1 is less than rs2, using unsigned comparison.
    code: |
      if (unsigned(rs1) < unsigned(rs2)) {
        next_pc = current_pc + (imm12 << 1)
      } else {
        next_pc = current_pc + 4
      }
    pseudos:
      BGTU:
        asm: bgtu rs1, rs2, imm12
        real: bltu rs2, rs1, imm12
        desc: BGTU take the branch if rs1 is greater than rs2, using unsigned comparison.
        code: |
          if (unsigned(rs1) > unsigned(rs2)) {
            next_pc = current_pc + (imm12 << 1)
          } else {
            next_pc = current_pc + 4
          }
  BGE:
    asm: bge rs1, rs2, imm12
    desc: BGE take the branch if rs1 is greater or equal than rs2, using signed comparison.
    code: |
      if (rs1 >= rs2) {
        next_pc = current_pc + (imm12 << 1)
      } else {
        next_pc = current_pc + 4
      }
    pseudos:
      GLE:
        asm: ble rs1, rs2, imm12
        real: bge rs2, rs1, imm12
        desc: BLE take the branch if rs1 is less or equal than rs2, using signed comparison.
        code: |
          if (rs1 > rs2) {
            next_pc = current_pc + (imm12 << 1)
          } else {
            next_pc = current_pc + 4
          }
      GLEZ:
        asm: blez rs2, imm12
        real: bge zero, rs2, imm12
  BGEU:
    asm: bgeu rs1, rs2, imm12
    desc: BGEU take the branch if rs1 is greater and equal than rs2, using unsigned comparison.
    code: |
      if (unsigned(rs1) >= unsigned(rs2)) {
        next_pc = current_pc + (imm12 << 1)
      } else {
        next_pc = current_pc + 4
      }
    pseudos:
      BLEU:
        asm: bleu rs1, rs2, imm12
        real: bgeu rs2, rs1, imm12
        desc: BLEU take the branch if rs1 is less or equal than rs2, using unsigned comparison.
        code: |
          if (unsigned(rs1) > unsigned(rs2)) {
            next_pc = current_pc + (imm12 << 1)
          } else {
            next_pc = current_pc + 4
          }

  # 2.6 Load and Store Instructions

  LW:
    asm: lw rd, imm12(rs1)
    desc: LW loads a 32-bit value from memory into rd.
  LH:
    asm: lh rd, imm12(rs1)
    desc: LH loads a 16-bit value from memory, then sign-extends to 32-bits before storing in rd.
  LHU:
    asm: lhu rd, imm12(rs1)
    desc: LHU loads a 16-bit value from memory, then zero extends to 32-bits before storing in rd.
  LB:
    asm: lb rd, imm12(rs1)
    desc: LB loads a 8-bit value from memory, then sign-extends to 32-bits before storing in rd.
  LBU:
    asm: lbu rd, imm12(rs1)
    desc: LBU loads a 8-bit value from memory, then zero extends to 32-bits before storing in rd.
  SW:
    asm: sw rs2, imm12(rs1)
    desc: SW stores 32-bit value from the register rs2 to memory.
  SH:
    asm: sh rs2, imm12(rs1)
    desc: SH stores 16-bit value from the low bits of register rs2 to memory.
  SB:
    asm: sb rs2, imm12(rs1)
    desc: SB stores 8-bit value from the low bits of register rs2 to memory.

  # 2.7 Memory Ordering Instructions
  FENCE:
    asm: fence pred, succ
    desc: |
      The FENCE instruction is used to order device I/O and memory accesses as viewed by other RISCV harts and external devices or coprocessors. Any combination of device input (I), device output (O), memory reads (R), and memory writes (W) may be ordered with respect to any combination of the same. Informally, no other RISC-V hart or external device can observe any operation in the successor set following a FENCE before any operation in the predecessor set preceding the FENCE.
      The FENCE instruction also orders memory reads and writes made by the hart as observed by memory reads and writes made by an external device. However, FENCE does not order observations of events made by an external device using any other signaling mechanism.
      pred: [iorw]+, succ: [iorw]+
      order是指FENCE指令前后操作（IORW中的某一个）的顺序会保持，FENCE指令之前的操作不会跑到后面的操作之后
    pseudos:
      FENCE:
        asm: fence
        real: fence iorw, iorw

  # 2.8 Environment Call and Breakpoints
  ECALL:
    asm: ecall
    desc: The ECALL instruction is used to make a service request to the execution environment. The EEI will define how parameters for the service request are passed, but usually these will be in defined locations in the integer register file.
  EBREAK:
    asm: ebreak
    desc: The EBREAK instruction is used to return control to a debugging environment.

RV64I: &id_rv64i
  <<: *id_rv32i
  meta:
    version: "2.1"
    desc: "base integer instruction set"
    XLEN: 64

  ADDIW:
    asm: addiw rd, rs1, imm12
    desc: ADDIW is an RV64I instruction that adds the sign-extended 12-bit immediate to register rs1 and produces the proper sign-extension of a 32-bit result in rd. Overflows are ignored and the result is the low 32 bits of the result sign-extended to 64 bits.
    code: |
      rd_32bit = sign_extend(imm12) + low_32bit(rs1)
      rd = sign_extend(rd_32bit)
    pseudos:
      SEXT.W:
        asm: sext.w rd, rs1
        real: addiw rd, rs1, 0
        desc: SEXT.W writes the sign-extension of the lower 32 bits of register rs1 into register rd.
        code: |
          rd = sign_extend(low_32bit(rs1))
  SLLI:
    asm: slli rd, rs1, uimm6
    desc: SLLI is a logical left shift (zeros are shifted into the lower bits).
    code: |
      rd = rs1 << uimm6
  SRLI:
    asm: srli rd, rs1, uimm6
    desc: SRLI is a logical right shift (zeros are shifted into the upper bits).
    code: |
      rd = unsigned(rs1) >> uimm6
  SRAI:
    asm: srai rd, rs1, uimm6
    desc: SRAI is an arithmetic right shift (the original sign bit is copied into the vacated upper bits).
    code: |
      rd = rs1 >> uimm6
  SLLIW:
    asm: slliw rd, rs1, uimm5
    desc: SLLIW is a logical left shift (zeros are shifted into the lower bits) and operates on the low 32-bit value of reigster rs1, then sign-extend the 32-bit result to 64 bits.
    code: |
      rd_32bit = low_32bit(rs1) << uimm5
      rd = sign_extend(rd_32bit)
  SRLIW:
    asm: srliw rd, rs1, uimm5
    desc: SRLIW is a logical right shift (zeros are shifted into the upper bits) and operates on the low 32-bit value of reigster rs1, then sign-extend the 32-bit result to 64 bits.
    code: |
      rd_32bit = unsigned(low_32bit(rs1)) >> uimm5
      rd = sign_extend(rd_32bit)
  SRAIW:
    asm: sraiw rd, rs1, uimm5
    desc: SRAIW is an arithmetic right shift (the original sign bit is copied into the vacated upper bits) and operates on the low 32-bit value of reigster rs1, then sign-extend the 32-bit result to 64 bits.
    code: |
      rd_32bit = low_32bit(rs1) >> uimm5
      rd = sign_extend(rd_32bit)
  LUI:
    asm: lui rd, imm20
    desc: LUI (load upper immediate) places the imm20 << 12 into register rd, filling in the lowest 12 bits with zeros. The 32-bit result is sign-extended to 64 bits.
    code: |
      rd_32bit = imm20 << 12
      rd = sign_extend(rd_32bit)
  AUIPC:
    asm: auipc rd, imm20
    desc: AUIPC (add upper immediate to pc) forms a 32-bit offset from the imm20, filling in the lowest 12 bits with zeros, sign-extends the result to 64 bits, adds it to the address of the AUIPC instruction, then places the result in register rd.
    code: |
      rd_32bit = imm20 << 12
      rd = pc + sign_extend(rd_32bit)
  SLL:
    asm: sll rd, rs1, rs2
    code: |
      shift_amount = low_6bit(rs2)
      rd = rs1 << shift_amount
  SRL:
    asm: srl rd, rs1, rs2
    code: |
      shift_amount = low_6bit(rs2)
      rd = rs1 >> shift_amount
  SRA:
    asm: sra rd, rs1, rs2
    code: |
      rd = unsigned(rs1) >> low_6bit(rs2)
      rd = unsigned(rs1) >> shift_amount
  SLLW:
    asm: sllw rd, rs1, rs2
    code: |
      shift_amount = low_5bit(rs2)
      rd_32bit = low_32bit(rs1) << shift_amount
      rd = sign_extend(rd_32bit)
  SRLW:
    asm: srlw rd, rs1, rs2
    code: |
      shift_amount = low_5bit(rs2)
      rd_32bit = unsigned(low_32bit(rs1)) >> shift_amount
      rd = sign_extend(rd_32bit)
  SRAW:
    asm: sraw rd, rs1, rs2
    code: |
      shift_amount = low_5bit(rs2)
      rd_32bit = low_32bit(rs1) >> shift_amount
      rd = sign_extend(rd_32bit)
  ADDW:
    asm: addw rd, rs1, rs2
    code: |
      rd_32bit = low_32bit(rs1) + low_32bit(rs2)
      rd = sign_extend(rd_32bit)
  SUBW:
    asm: sll rd, rs1, rs2
    code: |
      rd_32bit = low_32bit(rs1) - low_32bit(rs2)
      rd = sign_extend(rd_32bit)
  LD:
    asm: ld rd, imm12(rs1)
    desc: LD loads a 64-bit value from the memory into register rd for RV64I.
  LW:
    asm: lw rd, imm12(rs1)
    desc: LW loads a 32-bit value from the memory and sign-extends this to 64 bits before storing it in register rd.
  LWU:
    asm: lwu rd, imm12(rs1)
    desc: LWU loads a 32-bit value from the memory and zero-extends this to 64 bits before storing it in register rd.
  LH:
    asm: lh rd, imm12(rs1)
    desc: LH loads a 16-bit value from the memory and sign-extends this to 64 bits before storing it in register rd.
  LHU:
    asm: lhu rd, imm12(rs1)
    desc: LHU loads a 16-bit value from the memory and zero-extends this to 64 bits before storing it in register rd.
  LB:
    asm: lb rd, imm12(rs1)
    desc: LB loads a 8-bit value from the memory and sign-extends this to 64 bits before storing it in register rd.
  LBU:
    asm: lbu rd, imm12(rs1)
    desc: LBU loads a 8-bit value from the memory and zero-extends this to 64 bits before storing it in register rd.
  SD:
    asm: sd rs2, imm12(rs1)
    desc: SD stores the 64-bit value from register rs2 to memory.
  SW:
    asm: sw rs2, imm12(rs1)
    desc: SW stores the 32-bit value from the low bits of register rs2 to memory.
  SH:
    asm: sh rs2, imm12(rs1)
    desc: SH stores the 16-bit value from the low bits of register rs2 to memory.
  SB:
    asm: sb rs2, imm12(rs1)
    desc: SB stores the 8-bit value from the low bits of register rs2 to memory.

Zicsr:
  meta:
    version: "2.0"
    desc: "control and status register (CSR) instructions"
  CSRRW:
    asm: csrrw rd, rs1, csr
    desc: The CSRRW (Atomic Read/Write CSR) instruction atomically swaps values in the CSRs and integer registers. CSRRW reads the old value of the CSR, zero-extends the value to XLEN bits, then writes it to integer register rd. The initial value in rs1 is written to the CSR. If rd=x0, then the instruction shall not read the CSR and shall not cause any of the side effects that might occur on a CSR read.
  CSRRS:
    asm: csrrs rd, rs1, csr
    desc: |
      The CSRRS (Atomic Read and Set Bits in CSR) instruction reads the value of the CSR, zero-extends the value to XLEN bits, and writes it to integer register rd. The initial value in integer register rs1 is treated as a bit mask that specifies bit positions to be set in the CSR. Any bit that is high in rs1 will cause the corresponding bit to be set in the CSR, if that CSR bit is writable. Other bits in the CSR are unaffected (though CSRs might have side effects when written).
      For both CSRRS and CSRRC, if rs1=x0, then the instruction will not write to the CSR at all, and so shall not cause any of the side effects that might otherwise occur on a CSR write, nor raise illegal instruction exceptions on accesses to read-only CSRs. Both CSRRS and CSRRC always read the addressed CSR and cause any read side effects regardless of rs1 and rd fields. Note that if rs1 specifies a register holding a zero value other than x0, the instruction will still attempt to write the unmodified value back to the CSR and will cause any attendant side effects. A CSRRW with rs1=x0 will attempt to write zero to the destination CSR.
  CSRRC:
    asm: csrrc rd, rs1, csr
    desc: |
      The CSRRC (Atomic Read and Clear Bits in CSR) instruction reads the value of the CSR, zero-extends the value to XLEN bits, and writes it to integer register rd. The initial value in integer register rs1 is treated as a bit mask that specifies bit positions to be cleared in the CSR. Any bit that is high in rs1 will cause the corresponding bit to be cleared in the CSR, if that CSR bit is writable. Other bits in the CSR are unaffected.
      For both CSRRS and CSRRC, if rs1=x0, then the instruction will not write to the CSR at all, and so shall not cause any of the side effects that might otherwise occur on a CSR write, nor raise illegal instruction exceptions on accesses to read-only CSRs. Both CSRRS and CSRRC always read the addressed CSR and cause any read side effects regardless of rs1 and rd fields. Note that if rs1 specifies a register holding a zero value other than x0, the instruction will still attempt to write the unmodified value back to the CSR and will cause any attendant side effects. A CSRRW with rs1=x0 will attempt to write zero to the destination CSR.
  CSRRWI:
    asm: csrrwi rd, uimm5, csr
    desc: |
      The CSRRWI variant is similar to CSRRW, except it update the CSR using an XLEN-bit value obtained by zero-extending a 5-bit unsigned immediate (uimm[4:0]) field encoded in the rs1 field instead of a value from an integer register.
      For CSRRWI, if rd=x0, then the instruction shall not read the CSR and shall not cause any of the side effects that might occur on a CSR read.
  CSRRSI:
    asm: csrrsi rd, uimm5, csr
    desc: |
      The CSRRSI variant is similar to CSRRS, except it update the CSR using an XLEN-bit value obtained by zero-extending a 5-bit unsigned immediate (uimm[4:0]) field encoded in the rs1 field instead of a value from an integer register.
      For CSRRSI and CSRRCI, if the uimm[4:0] field is zero, then these instructions will not write to the CSR, and shall not cause any of the side effects that might otherwise occur on a CSR write, nor raise illegal instruction exceptions on accesses to read-only CSRs.
      Both CSRRSI and CSRRCI will always read the CSR and cause any read side effects regardless of rd and rs1 fields.
  CSRRCI:
    asm: csrrci rd, uimm5, csr
    desc: |
      The CSRRCI variant is similar to CSRRC, except it update the CSR using an XLEN-bit value obtained by zero-extending a 5-bit unsigned immediate (uimm[4:0]) field encoded in the rs1 field instead of a value from an integer register.
      For CSRRSI and CSRRCI, if the uimm[4:0] field is zero, then these instructions will not write to the CSR, and shall not cause any of the side effects that might otherwise occur on a CSR write, nor raise illegal instruction exceptions on accesses to read-only CSRs.
      Both CSRRSI and CSRRCI will always read the CSR and cause any read side effects regardless of rd and rs1 fields.

Zifencei:
  meta:
    version: "2.0"
    desc: "instruction-fetch fence instruction"
  FENCE.I:
    asm: fence.i
    desc: The FENCE.I instruction is used to synchronize the instruction and data streams. RISC-V does not guarantee that stores to instruction memory will be made visible to instruction fetches on a RISC-V hart until that hart executes a FENCE.I instruction. A FENCE.I instruction ensures that a subsequent instruction fetch on a RISC-V hart will see any previous data stores already visible to the same RISC-V hart. FENCE.I does not ensure that other RISC-V hart’s instruction fetches will observe the local hart’s stores in a multiprocessor system. To make a store to instruction memory visible to all RISC-V harts, the writing hart also has to execute a data FENCE before requesting that all remote RISC-V harts execute a FENCE.I.

Zihintpause:
  meta:
    version: "2.0"
  PAUSE:
    asm: pause
    desc: The PAUSE instruction is a HINT that indicates the current hart’s rate of instruction retirement should be temporarily reduced or paused. The duration of its effect must be bounded and may be zero. No architectural state is changed.

Zmmul: &id_zmmul
  meta:
    version: "0.1"
  MUL:
    asm: mul rd, rs1, rs2
    desc: MUL performs an XLEN-bit×XLEN-bit multiplication of rs1 by rs2 and places the lower XLEN bits in the destination register rd.
    code: |
      rd_2xXLEN_bit = rs1 * rs2
      rd = lower_XLEN_bit(rd_2xXLEN_bit)
  MULH:
    asm: mulh rd, rs1, rs2
    desc: MULH perform an XLEN-bit×XLEN-bit multiplication of rs1 by rs2 for signed×signed, and places the upper XLEN bits of the full 2×XLEN-bit product in the destination register rd.
    code: |
      rd_2xXLEN_bit = rs1 * rs2
      rd = upper_XLEN_bit(rd_2xXLEN_bit)
  MULHU:
    asm: mulhu rd, rs1, rs2
    desc: MULHU perform an XLEN-bit×XLEN-bit multiplication of rs1 by rs2 for unsigned×unsigned, and places the upper XLEN bits of the full 2×XLEN-bit product in the destination register rd.
    code: |
      rd_2xXLEN_bit = unsigned(rs1) * unsigned(rs2)
      rd = upper_XLEN_bit(rd_2xXLEN_bit)
  MULHSU:
    asm: mulhsu rd, rs1, rs2
    desc: MULHSU perform an XLEN-bit×XLEN-bit multiplication of rs1 by rs2 for signed×unsigned, and places the upper XLEN bits of the full 2×XLEN-bit product in the destination register rd.
    code: |
      rd_2xXLEN_bit = rs1 * unsigned(rs2)
      rd = upper_XLEN_bit(rd_2xXLEN_bit)
  MULW:
    only_base: [RV64]
    asm: mulw rd, rs1, rs2
    desc: MULW is an RV64 instruction that multiplies the lower 32 bits of the source registers, placing the sign-extension of the lower 32 bits of the result into the destination register.
    code: |
      rd_64bit = lower_32bit(rs1) * lower_32bit(rs2)
      rd = sign_extend(lower_32bit(rd_64bit))

M:
  <<: *id_zmmul
  meta:
    version: "2.0"
    desc: "integer multiplication and division instructions"
  DIV:
    asm: div rd, rs1, rs2
    desc: |
      DIV performs an XLEN bits by XLEN bits signed integer division of rs1 by rs2, rounding towards zero.
      If division by zero, the quotient is -1.
      If division overflow (i.e. only rs1 is -2^(XLEN - 1) and rs2 is -1), the quotient is -2^(XLEN - 1).
  DIVU:
    asm: divu rd, rs1, rs2
    desc: |
      DIVU performs an XLEN bits by XLEN bits unsigned integer division of rs1 by rs2, rounding towards zero.
      If division by zero, the quotient is 2^XLEN - 1.
  REM:
    asm: rem rd, rs1, rs2
    desc: |
      REM provides the signed remainder of the DIV division operation. The sign of the result equals the sign of the dividend.
      If division by zero, the remainder is rs1.
      If division overflow (i.e. only rs1 is -2^(XLEN - 1) and rs2 is -1), the remainder is 0.
  REMU:
    asm: remu rd, rs1, rs2
    desc: |
      REMU provides the unsigned remainder of the DIVU division operation.
      If division by zero, the remainder is rs1.
  DIVW:
    only_base: [RV64]
    asm: divw rd, rs1, rs2
    desc: |
      DIVW is RV64 instructions that divide the lower 32 bits of rs1 by the lower 32 bits of rs2, treating it as signed integer, placing the 32-bit quotient in rd, sign-extended to 64 bits.
      If division by zero, the quotient is -1, then sign-extended to 64 bits.
      If division overflow (i.e. only rs1 is -2^(XLEN - 1) and rs2 is -1), the quotient is -2^(XLEN - 1), then sign-extended to 64 bits.
    code: |
      rd_32bit = lower_32bit(rs1) / lower_32bit(rs2)
      rd = sign_extend(rd_32bit)
  DIVUW:
    only_base: [RV64]
    asm: divuw rd, rs1, rs2
    desc: |
      DIVUW is RV64 instructions that divide the lower 32 bits of rs1 by the lower 32 bits of rs2, treating it as unsigned integer, placing the 32-bit quotient in rd, sign-extended to 64 bits.
      If division by zero, the quotient is 2^32 - 1, then sign-extended to 64 bits.
    code: |
      rd_32bit = unsigned(lower_32bit(rs1)) / unsigned(lower_32bit(rs2))
      rd = sign_extend(rd_32bit)
  REMW:
    only_base: [RV64]
    asm: remw rd, rs1, rs2
    desc: |
      REMW is RV64 instructions that provides the signed remainder of the DIVW division operation and placing the remainder in rd, sign-extended to 64 bits. The sign of the result equals the sign of the dividend.
      If division by zero, the remainder is rs1, then sign-extended to 64 bits.
      If division overflow (i.e. only rs1 is -2^(XLEN - 1) and rs2 is -1), the remainder is 0, then sign-extended to 64 bits.
    code: |
      rd_32bit = lower_32bit(rs1) % lower_32bit(rs2)
      rd = sign_extend(rd_32bit)
  REMUW:
    only_base: [RV64]
    asm: remuw rd, rs1, rs2
    desc: |
      REMUW is RV64 instructions that provides the unsigned remainder of the DIVW division operation and placing the remainder in rd, sign-extended to 64 bits.
      If division by zero, the remainder is rs1, then sign-extended to 64 bits.
    code: |
      rd_32bit = unsigned(lower_32bit(rs1)) % unsigned(lower_32bit(rs2))
      rd = sign_extend(rd_32bit)

A:
  meta:
    version: "2.1"
    desc: "atomic instructions"
  LR.W:
    asm: lr.w rd, (rs1)
    desc: |
      LR.W loads a word from the address in rs1, places the sign-extended value in rd, and registers a reservation set--a set of bytes that subsumes the bytes in the addressed word.
      LR.W can with aq, rl and aqrl suffix which mean acquire, release, acquire and release access ordering respectively. e.g. `lr.w.aq rd, (rs1)`
  SC.W:
    asm: sc.w rd, rs2, (rs1)
    desc: |
      SC.W conditionally writes a word in rs2 to the address in rs1. The SC.W succeeds only if the reservation is still valid and the reservation set contains the bytes being written. If the SC.W succeeds, the instruction writes the word in rs2 to memory, and it writes zero to rd. If the SC.W fails, the instruction does not write to memory, and it writes a nonzero value to rd (sign-extend the value on RV64). Regardless of success or failure, executing an SC.W instruction invalidates any reservation held by this hart.
      SC.W can with aq, rl and aqrl suffix which mean acquire, release, acquire and release access ordering respectively. e.g. `sc.w.rl rd, (rs1)`
  LR.D:
    only_base: [RV64]
    asm: lr.d rd, (rs1)
    desc: |
      LR.D loads a doubleword from the address in rs1, places the sign-extended value in rd, and registers a reservation set--a set of bytes that subsumes the bytes in the addressed doubleword.
      LR.D can with aq, rl and aqrl suffix which mean acquire, release, acquire and release access ordering respectively. e.g. `lr.d.aq rd, (rs1)`
  SC.D:
    only_base: [RV64]
    asm: sc.d rd, rs2, (rs1)
    desc: |
      SC.D conditionally writes a doubleword in rs2 to the address in rs1. The SC.W succeeds only if the reservation is still valid and the reservation set contains the bytes being written. If the SC.W succeeds, the instruction writes the word in rs2 to memory, and it writes zero to rd. If the SC.W fails, the instruction does not write to memory, and it writes a nonzero value to rd. Regardless of success or failure, executing an SC.W instruction invalidates any reservation held by this hart.
      SC.D can with aq, rl and aqrl suffix which mean acquire, release, acquire and release access ordering respectively. e.g. `sc.d.rl rd, (rs1)`
  AMOSWAP.W:
    asm: amoswap.w rd, rs2, (rs1)
    desc: The AMOSWAP.W instruction atomically load a data value from the address in rs1, place the value into register rd, then store the value from register rs2 to the original address in rs1.
  AMOADD.W:
    asm: amoadd.w rd, rs2, (rs1)
    desc: The AMOADD.W instruction atomically load a data value from the address in rs1, place the value into register rd, apply a `add` operator to the loaded value and the original value in rs2, then store the result back to the original address in rs1.
  AMOAND.W:
    asm: amoand.w rd, rs2, (rs1)
    desc: The AMOAND.W instruction atomically load a data value from the address in rs1, place the value into register rd, apply a `and` operator to the loaded value and the original value in rs2, then store the result back to the original address in rs1.
  AMOOR.W:
    asm: amoor.w rd, rs2, (rs1)
    desc: The AMOOR.W instruction atomically load a data value from the address in rs1, place the value into register rd, apply a `or` operator to the loaded value and the original value in rs2, then store the result back to the original address in rs1.
  AMOXOR.W:
    asm: amoxor.w rd, rs2, (rs1)
    desc: The AMOXOR.W instruction atomically load a data value from the address in rs1, place the value into register rd, apply a `xor` operator to the loaded value and the original value in rs2, then store the result back to the original address in rs1.
  AMOMAX.W:
    asm: amomax.w rd, rs2, (rs1)
    desc: The AMOMAX.W instruction atomically load a data value from the address in rs1, place the value into register rd, apply a `max` operator to the loaded value and the original value in rs2, then store the result back to the original address in rs1.
  AMOMAXU.W:
    asm: amomaxu.w rd, rs2, (rs1)
    desc: The AMOMAXU.W instruction atomically load a data value from the address in rs1, place the value into register rd, apply a `max` unsigned operator to the loaded value and the original value in rs2, then store the result back to the original address in rs1.
  AMOMIN.W:
    asm: amomin.w rd, rs2, (rs1)
    desc: These AMOMIN.W instruction atomically load a data value from the address in rs1, place the value into register rd, apply a `min` operator to the loaded value and the original value in rs2, then store the result back to the original address in rs1.
  AMOMINU.W:
    asm: amominu.w rd, rs2, (rs1)
    desc: These AMOMINU.W instruction atomically load a data value from the address in rs1, place the value into register rd, apply a `min` unsigned operator to the loaded value and the original value in rs2, then store the result back to the original address in rs1.
  AMOSWAP.D:
    asm: amoswap.d rd, rs2, (rs1)
    desc: The AMOSWAP.D instruction atomically load a data value from the address in rs1, place the value into register rd, then store the value from register rs2 to the original address in rs1.
  AMOADD.D:
    asm: amoadd.d rd, rs2, (rs1)
    desc: The AMOADD.D instruction atomically load a data value from the address in rs1, place the value into register rd, apply a `add` operator to the loaded value and the original value in rs2, then store the result back to the original address in rs1.
  AMOAND.D:
    asm: amoand.d rd, rs2, (rs1)
    desc: The AMOAND.D instruction atomically load a data value from the address in rs1, place the value into register rd, apply a `and` operator to the loaded value and the original value in rs2, then store the result back to the original address in rs1.
  AMOOR.D:
    asm: amoor.d rd, rs2, (rs1)
    desc: The AMOOR.D instruction atomically load a data value from the address in rs1, place the value into register rd, apply a `or` operator to the loaded value and the original value in rs2, then store the result back to the original address in rs1.
  AMOXOR.D:
    asm: amoxor.d rd, rs2, (rs1)
    desc: The AMOXOR.D instruction atomically load a data value from the address in rs1, place the value into register rd, apply a `xor` operator to the loaded value and the original value in rs2, then store the result back to the original address in rs1.
  AMOMAX.D:
    asm: amomax.d rd, rs2, (rs1)
    desc: The AMOMAX.D instruction atomically load a data value from the address in rs1, place the value into register rd, apply a `max` operator to the loaded value and the original value in rs2, then store the result back to the original address in rs1.
  AMOMAXU.D:
    asm: amomaxu.d rd, rs2, (rs1)
    desc: The AMOMAXU.D instruction atomically load a data value from the address in rs1, place the value into register rd, apply a `max` unsigned operator to the loaded value and the original value in rs2, then store the result back to the original address in rs1.
  AMOMIN.D:
    asm: amomin.d rd, rs2, (rs1)
    desc: These AMOMIN.D instruction atomically load a data value from the address in rs1, place the value into register rd, apply a `min` operator to the loaded value and the original value in rs2, then store the result back to the original address in rs1.
  AMOMINU.D:
    asm: amominu.d rd, rs2, (rs1)
    desc: These AMOMINU.D instruction atomically load a data value from the address in rs1, place the value into register rd, apply a `min` unsigned operator to the loaded value and the original value in rs2, then store the result back to the original address in rs1.

F:
  meta:
    version: "2.2"
    desc: "A Standard Extension for Single-Precision Floating-Point"
    notations: |
      Rounding Mode     Mnemonic      Meaning
      =============     ========      =======
      000               RNE           Round to Nearest, ties to Even
      001               RTZ           Round towards Zero
      010               RDN           Round Down (towards −∞)
      011               RUP           Round Up (towards +∞)
      100               RMM           Round to Nearest, ties to Max Magnitude
      101                             Reserved for future use.
      110                             Reserved for future use.
      111               DYN           In instruction’s rm field, selects dynamic rounding mode;
                                      In Rounding Mode register, reserved.
  # 13.5 Single-Precision Load and Store Instructions
  FLW:
    asm: flw rd, imm12(rs1)
    desc: The FLW instruction loads a single-precision floating-point value from memory into floating-point register rd. FLW and FSW do not modify the bits being transferred; in particular, the payloads of non-canonical NaNs are preserved.
  FSW:
    asm: fsw rs2, imm12(rs1)
    desc: FSW stores a single-precision value from floating-point register rs2 to memory. FLW and FSW are only guaranteed to execute atomically if the effective address is naturally aligned.
  # 13.6 Single-Precision Floating-Point Computational Instructions
  FADD.S:
    asm: fadd.s rd, rs1, rs2, rm
    desc: FADD.S and FMUL.S perform single-precision floating-point addition and multiplication respectively, between rs1 and rs2.
  FMUL.S:
    asm: fadd.s rd, rs1, rs2, rm
    desc: FADD.S and FMUL.S perform single-precision floating-point addition and multiplication respectively, between rs1 and rs2.
  FSUB.S:
    asm: fsub.s rd, rs1, rs2, rm
    desc: FSUB.S performs the single-precision floating-point subtraction of rs2 from rs1.
  FDIV.s:
    asm: fdiv.s rd, rs1, rs2, rm
    desc: FDIV.S performs the single-precision floating-point division of rs1 by rs2.
  FSQRT.S:
    asm: fsqrt.s rd, rs1, rm
    desc: FSQRT.S computes the square root of rs1. In each case, the result is written to rd.
  FMIN.S:
    asm: fmin.s rd, rs1, rs2
    desc: Floating-point minimum-number and maximum-number instructions FMIN.S and FMAX.S write, respectively, the smaller or larger of rs1 and rs2 to rd.
  FMAX.S:
    asm: fmax.s rd, rs1, rs2
    desc: Floating-point minimum-number and maximum-number instructions FMIN.S and FMAX.S write, respectively, the smaller or larger of rs1 and rs2 to rd.
  FMADD.S:
    asm: fmadd.s rd, rs1, rs2, rs3, rm
    desc: FMADD.S multiplies the values in rs1 and rs2, adds the value in rs3, and writes the final result to rd. FMADD.S computes (rs1×rs2)+rs3.
  FMSUB.S:
    asm: fmsub.s rd, rs1, rs2, rs3, rm
    desc: FMSUB.S multiplies the values in rs1 and rs2, subtracts the value in rs3, and writes the final result to rd. FMSUB.S computes (rs1×rs2)-rs3.
  FNMSUB.S:
    asm: fnmsub.s rd, rs1, rs2, rs3, rm
    desc: FNMSUB.S multiplies the values in rs1 and rs2, negates the product, adds the value in rs3, and writes the final result to rd. FNMSUB.S computes -(rs1×rs2)+rs3.
  FNMADD.S:
    asm: fnmadd.s rd, rs1, rs2, rs3, rm
    desc: FNMADD.S multiplies the values in rs1 and rs2, negates the product, subtracts the value in rs3, and writes the final result to rd. FNMADD.S computes -(rs1×rs2)-rs3.
  # 13.7 Single-Precision Floating-Point Conversion and Move Instructions
  FCVT.W.S:
    asm: fcvt.w.s rd, rs1, rm
    desc: |
      FCVT.W.S or FCVT.L.S converts a floating-point number in floating-point register rs1 to a signed 32-bit or 64-bit integer, respectively, in integer register rd.
      For XLEN>32, FCVT.W[U].S sign-extends the 32-bit result to the destination register width.
  FCVT.L.S:
    only_base: [rv64]
    asm: fcvt.l.s rd, rs1, rm
    desc: FCVT.W.S or FCVT.L.S converts a floating-point number in floating-point register rs1 to a signed 32-bit or 64-bit integer, respectively, in integer register rd.
  FCVT.S.W:
    asm: fcvt.s.w rd, rs1, rm
    desc: |
      FCVT.S.W or FCVT.S.L converts a 32-bit or 64-bit signed integer, respectively, in integer register rs1 into a floating-point number in floating-point register rd.
      A floating-point register can be initialized to floating-point positive zero using FCVT.S.W rd, x0, which will never set any exception flags.
  FCVT.S.L:
    only_base: [rv64]
    asm: fcvt.s.l rd, rs1, rm
    desc: FCVT.S.W or FCVT.S.L converts a 32-bit or 64-bit signed integer, respectively, in integer register rs1 into a floating-point number in floating-point register rd.
  FCVT.WU.S:
    asm: fcvt.wu.s rd, rs1, rm
    desc: |
      FCVT.WU.S, FCVT.LU.S, FCVT.S.WU, and FCVT.S.LU variants convert to or from unsigned integer values.
      For XLEN>32, FCVT.W[U].S sign-extends the 32-bit result to the destination register width.
  FCVT.LU.S:
    only_base: [rv64]
    asm: fcvt.lu.s rd, rs1, rm
    desc: FCVT.WU.S, FCVT.LU.S, FCVT.S.WU, and FCVT.S.LU variants convert to or from unsigned integer values.
  FCVT.S.WU:
    asm: fcvt.s.wu rd, rs1, rm
    desc: FCVT.WU.S, FCVT.LU.S, FCVT.S.WU, and FCVT.S.LU variants convert to or from unsigned integer values.
  FCVT.S.LU:
    only_base: [rv64]
    asm: fcvt.s.lu rd, rs1, rm
    desc: FCVT.WU.S, FCVT.LU.S, FCVT.S.WU, and FCVT.S.LU variants convert to or from unsigned integer values.
  FSGNJ.S:
    asm: fsgnj.s rd, rs1, rs2, rm
    desc: Floating-point to floating-point sign-injection instructions, FSGNJ.S, FSGNJN.S, and FSGNJX.S, produce a result that takes all bits except the sign bit from rs1. For FSGNJ, the result’s sign bit is rs2’s sign bit.
  FSGNJN.S:
    asm: fsgnjn.s rd, rs1, rs2, rm
    desc: Floating-point to floating-point sign-injection instructions, FSGNJ.S, FSGNJN.S, and FSGNJX.S, produce a result that takes all bits except the sign bit from rs1. For FSGNJN, the result’s sign bit is the opposite of rs2’s sign bit.
  FSGNJX.S:
    asm: fsgnjx.s rd, rs1, rs2, rm
    desc: Floating-point to floating-point sign-injection instructions, FSGNJ.S, FSGNJN.S, and FSGNJX.S, produce a result that takes all bits except the sign bit from rs1. For FSGNJX, the result’s sign bit is the XOR of the sign bits of rs1 and rs2.
  FMV.X.W:
    asm: fmv.x.w rd, rs1
    desc: FMV.X.W moves the single-precision value in floating-point register rs1 represented in IEEE 754-2008 encoding to the lower 32 bits of integer register rd. The bits are not modified in the transfer, and in particular, the payloads of non-canonical NaNs are preserved. For RV64, the higher 32 bits of the destination register are filled with copies of the floating-point number’s sign bit.
  FMV.W.X:
    asm: fmv.w.x rd, rs1
    desc: FMV.W.X moves the single-precision value encoded in IEEE 754-2008 standard encoding from the lower 32 bits of integer register rs1 to the floating-point register rd. The bits are not modified in the transfer, and in particular, the payloads of non-canonical NaNs are preserved.
  # 13.8 Single-Precision Floating-Point Compare Instructions
  FEQ.S:
    asm: feq.s rd, rs1, rs2
    desc: |
      Floating-point compare instructions (FEQ.S, FLT.S, FLE.S) perform the specified comparison between floating-point registers (rs1 = rs2, rs1 < rs2, rs1 ≤ rs2) writing 1 to the integer register rd if the condition holds, and 0 otherwise. 
      FEQ.S performs a quiet comparison: it only sets the invalid operation exception flag if either input is a signaling NaN. For all three instructions, the result is 0 if either operand is NaN.
  FLT.S:
    asm: flt.s rd, rs1, rs2
    desc: |
      Floating-point compare instructions (FEQ.S, FLT.S, FLE.S) perform the specified comparison between floating-point registers (rs1 = rs2, rs1 < rs2, rs1 ≤ rs2) writing 1 to the integer register rd if the condition holds, and 0 otherwise. 
      FLT.S and FLE.S perform what the IEEE 754-2008 standard refers to as signaling comparisons: that is, they set the invalid operation exception flag if either input is NaN. For all three instructions, the result is 0 if either operand is NaN.
  FLE.S:
    asm: fle.s rd, rs1, rs2
    desc: |
      Floating-point compare instructions (FEQ.S, FLT.S, FLE.S) perform the specified comparison between floating-point registers (rs1 = rs2, rs1 < rs2, rs1 ≤ rs2) writing 1 to the integer register rd if the condition holds, and 0 otherwise. 
      FLT.S and FLE.S perform what the IEEE 754-2008 standard refers to as signaling comparisons: that is, they set the invalid operation exception flag if either input is NaN. For all three instructions, the result is 0 if either operand is NaN.
  # 13.9 Single-Precision Floating-Point Classify Instruction
  FCLASS.S:
    asm: fclass.s rd, rs1
    desc: |
      The FCLASS.S instruction examines the value in floating-point register rs1 and writes to integer register rd a 10-bit mask that indicates the class of the floating-point number. The format of the mask is described below. The corresponding bit in rd will be set if the property is true and clear otherwise. All other bits in rd are cleared. Note that exactly one bit in rd will be set. FCLASS.S does not set the floating-point exception flags.

      rd bit      Meaning
      0           rs1 is −∞.
      1           rs1 is a negative normal number.
      2           rs1 is a negative subnormal number.
      3           rs1 is −0.
      4           rs1 is +0.
      5           rs1 is a positive subnormal number.
      6           rs1 is a positive normal number.
      7           rs1 is +∞.
      8           rs1 is a signaling NaN.
      9           rs1 is a quiet NaN.

D:
  meta:
    version: "2.2"
    desc: "double-precision floating-point instructions"
    notations: |
      Rounding Mode     Mnemonic      Meaning
      =============     ========      =======
      000               RNE           Round to Nearest, ties to Even
      001               RTZ           Round towards Zero
      010               RDN           Round Down (towards −∞)
      011               RUP           Round Up (towards +∞)
      100               RMM           Round to Nearest, ties to Max Magnitude
      101                             Reserved for future use.
      110                             Reserved for future use.
      111               DYN           In instruction’s rm field, selects dynamic rounding mode;
                                      In Rounding Mode register, reserved.
  # 14.3 Double-Precision Load and Store Instructions
  FLD:
    asm: fld rd, imm12(rs1)
    desc: |
      The FLD instruction loads a double-precision floating-point value from memory into floating-point register rd.
      FLD and FSD do not modify the bits being transferred; in particular, the payloads of non-canonical NaNs are preserved.
  FSD:
    asm: fsd rs2, imm12(rs1)
    desc: |
      FSD stores a double-precision value from the floating-point registers to memory.
      FLD and FSD do not modify the bits being transferred; in particular, the payloads of non-canonical NaNs are preserved.
  # 14.4 Double-Precision Floating-Point Computational Instructions
  FADD.D:
    asm: fadd.d rd, rs1, rs2, rm
    desc: FADD.D and FMUL.D perform double-precision floating-point addition and multiplication respectively, between rs1 and rs2.
  FMUL.D:
    asm: fadd.d rd, rs1, rs2, rm
    desc: FADD.D and FMUL.D perform double-precision floating-point addition and multiplication respectively, between rs1 and rs2.
  FSUB.d:
    asm: fsub.d rd, rs1, rs2, rm
    desc: FSUB.D performs the double-precision floating-point subtraction of rs2 from rs1.
  FDIV.d:
    asm: fdiv.d rd, rs1, rs2, rm
    desc: FDIV.D performs the double-precision floating-point division of rs1 by rs2.
  FSQRT.D:
    asm: fsqrt.d rd, rs1, rm
    desc: FSQRT.D computes the square root of rs1. In each case, the result is written to rd.
  FMIN.D:
    asm: fmin.d rd, rs1, rs2
    desc: Floating-point minimum-number and maximum-number instructions FMIN.D and FMAX.D write, respectively, the smaller or larger of rs1 and rs2 to rd.
  FMAX.D:
    asm: fmax.d rd, rs1, rs2
    desc: Floating-point minimum-number and maximum-number instructions FMIN.D and FMAX.D write, respectively, the smaller or larger of rs1 and rs2 to rd.
  FMADD.D:
    asm: fmadd.d rd, rs1, rs2, rs3, rm
    desc: FMADD.D multiplies the values in rs1 and rs2, adds the value in rs3, and writes the final result to rd. FMADD.D computes (rs1×rs2)+rs3.
  FMSUB.D:
    asm: fmsub.d rd, rs1, rs2, rs3, rm
    desc: FMSUB.D multiplies the values in rs1 and rs2, subtracts the value in rs3, and writes the final result to rd. FMSUB.D computes (rs1×rs2)-rs3.
  FNMSUB.D:
    asm: fnmsub.d rd, rs1, rs2, rs3, rm
    desc: FNMSUB.D multiplies the values in rs1 and rs2, negates the product, adds the value in rs3, and writes the final result to rd. FNMSUB.D computes -(rs1×rs2)+rs3.
  FNMADD.D:
    asm: fnmadd.d rd, rs1, rs2, rs3, rm
    desc: FNMADD.D multiplies the values in rs1 and rs2, negates the product, subtracts the value in rs3, and writes the final result to rd. FNMADD.D computes -(rs1×rs2)-rs3.
  # 14.5 Double-Precision Floating-Point Conversion and Move Instructions
  FCVT.W.D:
    asm: fcvt.w.d rd, rs1, rm
    desc: |
      FCVT.W.D or FCVT.L.D converts a double-precision floating-point number in floating-point register rs1 to a signed 32-bit or 64-bit integer, respectively, in integer register rd.
      For RV64, FCVT.W[U].D sign-extends the 32-bit result.
  FCVT.L.D:
    only_base: [rv64]
    asm: fcvt.l.d rd, rs1, rm
    desc: FCVT.W.D or FCVT.L.D converts a floating-point number in floating-point register rs1 to a signed 32-bit or 64-bit integer, respectively, in integer register rd.
  FCVT.D.W:
    asm: fcvt.d.w rd, rs1, rm
    desc: |
      FCVT.D.W or FCVT.D.L converts a 32-bit or 64-bit signed integer, respectively, in integer register rs1 into a double-precision floating-point number in floating-point register rd.
  FCVT.D.L:
    only_base: [rv64]
    asm: fcvt.d.l rd, rs1, rm
    desc: FCVT.D.W or FCVT.D.L converts a 32-bit or 64-bit signed integer, respectively, in integer register rs1 into a double-precision floating-point number in floating-point register rd.
  FCVT.WU.D:
    asm: fcvt.wu.d rd, rs1, rm
    desc: |
      FCVT.WU.D, FCVT.LU.D, FCVT.D.WU, and FCVT.D.LU variants convert to or from unsigned integer values.
      For RV64, FCVT.W[U].D sign-extends the 32-bit result.
  FCVT.LU.D:
    only_base: [rv64]
    asm: fcvt.lu.d rd, rs1, rm
    desc: FCVT.WU.D, FCVT.LU.D, FCVT.D.WU, and FCVT.D.LU variants convert to or from unsigned integer values.
  FCVT.D.WU:
    asm: fcvt.d.wu rd, rs1, rm
    desc: FCVT.WU.D, FCVT.LU.D, FCVT.D.WU, and FCVT.D.LU variants convert to or from unsigned integer values.
  FCVT.D.LU:
    only_base: [rv64]
    asm: fcvt.d.lu rd, rs1, rm
    desc: FCVT.WU.D, FCVT.LU.D, FCVT.D.WU, and FCVT.D.LU variants convert to or from unsigned integer values.
  FCVT.S.D:
    asm: fcvt.s.d rd, rs1, rm
    desc: The double-precision to single-precision and single-precision to double-precision conversion instructions, FCVT.S.D and FCVT.D.S, are encoded in the OP-FP major opcode space and both the source and destination are floating-point registers. The rs2 field encodes the datatype of the source, and the fmt field encodes the datatype of the destination. FCVT.S.D rounds according to the RM field; FCVT.D.S will never round.
  FCVT.D.S:
    asm: fcvt.d.s rd, rs1, rm
    desc: The double-precision to single-precision and single-precision to double-precision conversion instructions, FCVT.S.D and FCVT.D.S, are encoded in the OP-FP major opcode space and both the source and destination are floating-point registers. The rs2 field encodes the datatype of the source, and the fmt field encodes the datatype of the destination. FCVT.S.D rounds according to the RM field; FCVT.D.S will never round.
  FSGNJ.D:
    asm: fsgnj.d rd, rs1, rs2, rm
    desc: Floating-point to floating-point sign-injection instructions, FSGNJ.D, FSGNJN.D, and FSGNJX.D, produce a result that takes all bits except the sign bit from rs1. For FSGNJ, the result’s sign bit is rs2’s sign bit.
  FSGNJN.D:
    asm: fsgnjn.d rd, rs1, rs2, rm
    desc: Floating-point to floating-point sign-injection instructions, FSGNJ.D, FSGNJN.D, and FSGNJX.D, produce a result that takes all bits except the sign bit from rs1. For FSGNJN, the result’s sign bit is the opposite of rs2’s sign bit.
  FSGNJX.D:
    asm: fsgnjx.d rd, rs1, rs2, rm
    desc: Floating-point to floating-point sign-injection instructions, FSGNJ.D, FSGNJN.D, and FSGNJX.D, produce a result that takes all bits except the sign bit from rs1. For FSGNJX, the result’s sign bit is the XOR of the sign bits of rs1 and rs2.
  FMV.X.D:
    asm: fmv.x.d rd, rs1
    desc: FMV.X.D moves the double-precision value in floating-point register rs1 represented in IEEE 754-2008 encoding to the lower 32 bits of integer register rd. The bits are not modified in the transfer, and in particular, the payloads of non-canonical NaNs are preserved. For RV64, the higher 32 bits of the destination register are filled with copies of the floating-point number’s sign bit.
  FMV.D.X:
    asm: fmv.d.x rd, rs1
    desc: FMV.D.X moves the double-precision value encoded in IEEE 754-2008 standard encoding from the lower 32 bits of integer register rs1 to the floating-point register rd. The bits are not modified in the transfer, and in particular, the payloads of non-canonical NaNs are preserved.
  # 14.6 Double-Precision Floating-Point Compare Instructions
  FEQ.D:
    asm: feq.d rd, rs1, rs2
    desc: |
      Floating-point compare instructions (FEQ.D, FLT.D, FLE.D) perform the specified comparison between floating-point registers (rs1 = rs2, rs1 < rs2, rs1 ≤ rs2) writing 1 to the integer register rd if the condition holds, and 0 otherwise. 
      FEQ.D performs a quiet comparison: it only sets the invalid operation exception flag if either input is a signaling NaN. For all three instructions, the result is 0 if either operand is NaN.
  FLT.D:
    asm: flt.d rd, rs1, rs2
    desc: |
      Floating-point compare instructions (FEQ.D, FLT.D, FLE.D) perform the specified comparison between floating-point registers (rs1 = rs2, rs1 < rs2, rs1 ≤ rs2) writing 1 to the integer register rd if the condition holds, and 0 otherwise. 
      FLT.D and FLE.D perform what the IEEE 754-2008 standard refers to as signaling comparisons: that is, they set the invalid operation exception flag if either input is NaN. For all three instructions, the result is 0 if either operand is NaN.
  FLE.D:
    asm: fle.d rd, rs1, rs2
    desc: |
      Floating-point compare instructions (FEQ.D, FLT.D, FLE.D) perform the specified comparison between floating-point registers (rs1 = rs2, rs1 < rs2, rs1 ≤ rs2) writing 1 to the integer register rd if the condition holds, and 0 otherwise. 
      FLT.D and FLE.D perform what the IEEE 754-2008 standard refers to as signaling comparisons: that is, they set the invalid operation exception flag if either input is NaN. For all three instructions, the result is 0 if either operand is NaN.
  # 14.7 Double-Precision Floating-Point Classify Instruction
  FCLASS.D:
    asm: fclass.d rd, rs1
    desc: |
      The FCLASS.D instruction examines the value in floating-point register rs1 and writes to integer register rd a 10-bit mask that indicates the class of the floating-point number. The format of the mask is described below. The corresponding bit in rd will be set if the property is true and clear otherwise. All other bits in rd are cleared. Note that exactly one bit in rd will be set. FCLASS.D does not set the floating-point exception flags.

      rd bit      Meaning
      0           rs1 is −∞.
      1           rs1 is a negative normal number.
      2           rs1 is a negative subnormal number.
      3           rs1 is −0.
      4           rs1 is +0.
      5           rs1 is a positive subnormal number.
      6           rs1 is a positive normal number.
      7           rs1 is +∞.
      8           rs1 is a signaling NaN.
      9           rs1 is a quiet NaN.

Q:
  meta:
    version: "2.2"
    desc: "quad-precision floating-point instructions"

C:
  meta:
    version: "2.0"
    desc: "compressed instructions."
    notations: |
      compression scheme:
        - the immediate or address offset is small, or
        - one of the registers is the zero register (x0), the ABI link register (x1), or the ABI stack pointer (x2), or
        - the destination register and the first source register are identical, or
        - the registers used are the 8 most popular ones.
      
      rd', rs1', rs2': use 3 bits for x8(0b000) ~ x15(0b111) (s0, s1, a0~a5) or f8 ~ f15(fs0, fs1, fa0~fa5)

  # Stack-Pointer-Based Loads and Stores
  C.LWSP:
    asm: c.lwsp rd, imm6
    desc: C.LWSP loads a 32-bit value from memory into register rd. It computes an effective address by adding the zero-extended offset, scaled by 4, to the stack pointer, x2. It expands to lw rd, offset(x2). C.LWSP is only valid when rd̸=x0; the code points with rd=x0 are reserved.
    code: |
      offset = zero_extend(imm6) << 2
      rd = mem[x2 + offset]
  C.LDSP:
    only_base: [RV64, RV128]
    asm: c.ldsp rd, imm6
    desc: C.LDSP is an RV64C/RV128C-only instruction that loads a 64-bit value from memory into register rd. It computes its effective address by adding the zero-extended offset, scaled by 8, to the stack pointer, x2. It expands to ld rd, offset(x2). C.LDSP is only valid when rd̸=x0; the code points with rd=x0 are reserved.
    code: |
      offset = zero_extend(imm6) << 3
      rd = mem[x2 + offset]
  C.LQSP:
    only_base: [RV128]
    asm: c.lqsp rd, imm6
    desc: C.LQSP is an RV128C-only instruction that loads a 128-bit value from memory into register rd. It computes its effective address by adding the zero-extended offset, scaled by 16, to the stack pointer, x2. It expands to lq rd, offset(x2). C.LQSP is only valid when rd̸=x0; the code points with rd=x0 are reserved.
    code: |
      offset = zero_extend(imm6) << 4
      rd = mem[x2 + offset]
  C.FLWSP:
    only_base: [RV32]
    asm: c.flwsp rd, imm6
    desc: C.FLWSP is an RV32FC-only instruction that loads a single-precision floating-point value from memory into floating-point register rd. It computes its effective address by adding the zero-extended offset, scaled by 4, to the stack pointer, x2. It expands to flw rd, offset(x2).
    code: |
      offset = zero_extend(imm6) << 2
      rd = mem[x2 + offset]
  C.FLDSP:
    asm: c.fldsp rd, imm6
    desc: C.FLDSP is an RV32DC/RV64DC-only instruction that loads a double-precision floating-point value from memory into floating-point register rd. It computes its effective address by adding the zero-extended offset, scaled by 8, to the stack pointer, x2. It expands to fld rd, offset(x2).
    code: |
      offset = zero_extend(imm6) << 3
      rd = mem[x2 + offset]
  C.SWSP:
    asm: c.swsp rs2, imm6
    desc: C.SWSP stores a 32-bit value in register rs2 to memory. It computes an effective address by adding the zero-extended offset, scaled by 4, to the stack pointer, x2. It expands to sw rs2, offset(x2).
    code: |
      offset = zero_extend(imm6) << 2
      mem[x2 + offset] = rs2
  C.SDSP:
    only_base: [RV64, RV128]
    asm: c.sdsp rs2, imm6
    desc: C.SDSP is an RV64C/RV128C-only instruction that stores a 64-bit value in register rs2 to memory. It computes an effective address by adding the zero-extended offset, scaled by 8, to the stack pointer, x2. It expands to sd rs2, offset(x2).
    code: |
      offset = zero_extend(imm6) << 3
      mem[x2 + offset] = rs2
  C.SQSP:
    only_base: [RV128]
    asm: c.sqsp rs2, imm6
    desc: C.SQSP is an RV128C-only instruction that stores a 128-bit value in register rs2 to memory. It computes an effective address by adding the zero-extended offset, scaled by 16, to the stack pointer, x2. It expands to sq rs2, offset(x2).
    code: |
      offset = zero_extend(imm6) << 4
      mem[x2 + offset] = rs2
  C.FSWSP:
    only_base: [RV32]
    asm: c.fswsp rs2, imm6
    desc: C.FSWSP is an RV32FC-only instruction that stores a single-precision floating-point value in floating-point register rs2 to memory. It computes an effective address by adding the zero-extended offset, scaled by 4, to the stack pointer, x2. It expands to fsw rs2, offset(x2).
    code: |
      offset = zero_extend(imm6) << 2
      mem[x2 + offset] = rs2
  C.FSDSP:
    asm: c.fsdsp rs2, imm6
    desc: C.FSDSP is an RV32DC/RV64DC-only instruction that stores a double-precision floating-point value in floating-point register rs2 to memory. It computes an effective address by adding the zero-extended offset, scaled by 8, to the stack pointer, x2. It expands to fsd rs2, offset(x2).
    code: |
      offset = zero_extend(imm6) << 3
      mem[x2 + offset] = rs2
  # Register-Based Loads and Stores
  C.LW:
    asm: c.lw rd', imm5(rs1')
    desc: C.LW loads a 32-bit value from memory into register rd′. It computes an effective address by adding the zero-extended offset, scaled by 4, to the base address in register rs1′. It expands to lw rd′, offset(rs1′).
    code: |
      offset = zero_extend(imm5) << 2
      rd' = mem[rs1' + offset]
  C.LD:
    only_base: [RV64, RV128]
    asm: c.ld rd', imm5(rs1')
    desc: C.LD is an RV64C/RV128C-only instruction that loads a 64-bit value from memory into register rd′. It computes an effective address by adding the zero-extended offset, scaled by 8, to the base address in register rs1′. It expands to ld rd′, offset(rs1′).
    code: |
      offset = zero_extend(imm5) << 3
      rd' = mem[rs1' + offset]
  C.LQ:
    only_base: [RV128]
    asm: c.lq rd', imm5(rs1')
    desc: C.LQ is an RV128C-only instruction that loads a 128-bit value from memory into register rd ′. It computes an effective address by adding the zero-extended offset, scaled by 16, to the base address in register rs1 ′. It expands to lq rd ′, offset(rs1 ′).
    code: |
      offset = zero_extend(imm5) << 4
      rd' = mem[rs1' + offset]
  C.FLW:
    only_base: [RV32]
    asm: c.flw rd', imm5(rs1')
    desc: C.FLW is an RV32FC-only instruction that loads a single-precision floating-point value from memory into floating-point register rd ′. It computes an effective address by adding the zero-extended offset, scaled by 4, to the base address in register rs1 ′. It expands to flw rd ′, offset(rs1 ′).
    code: |
      offset = zero_extend(imm5) << 2
      rd' = mem[rs1' + offset]
  C.FLD:
    asm: c.fld rd', imm5(rs1')
    desc: C.FLD is an RV32DC/RV64DC-only instruction that loads a double-precision floating-point value from memory into floating-point register rd ′. It computes an effective address by adding the zero-extended offset, scaled by 8, to the base address in register rs1 ′. It expands to fld rd ′, offset(rs1 ′).
    code: |
      offset = zero_extend(imm5) << 3
      rd' = mem[rs1' + offset]
  C.SW:
    asm: c.sw rs2', imm5(rs1')
    desc: C.SW stores a 32-bit value in register rs2 ′ to memory. It computes an effective address by adding the zero-extended offset, scaled by 4, to the base address in register rs1 ′. It expands to sw rs2 ′, offset(rs1 ′).
    code: |
      offset = zero_extend(imm5) << 2
      mem[rs1' + offset] = rs2'
  C.SD:
    only_base: [RV64, RV128]
    asm: c.sd rs2', imm5(rs1')
    desc: C.SD is an RV64C/RV128C-only instruction that stores a 64-bit value in register rs2 ′ to memory. It computes an effective address by adding the zero-extended offset, scaled by 8, to the base address in register rs1 ′. It expands to sd rs2 ′, offset(rs1 ′).
    code: |
      offset = zero_extend(imm5) << 3
      mem[rs1' + offset] = rs2'
  C.SQ:
    only_base: [RV128]
    asm: c.sq rs2', imm5(rs1')
    desc: C.SQ is an RV128C-only instruction that stores a 128-bit value in register rs2 ′ to memory. It computes an effective address by adding the zero-extended offset, scaled by 16, to the base address in register rs1 ′. It expands to sq rs2 ′, offset(rs1 ′).
    code: |
      offset = zero_extend(imm5) << 4
      mem[rs1' + offset] = rs2'
  C.FSW:
    only_base: [RV32]
    require: [f]
    asm: c.fsw rs2', imm5(rs1')
    desc: C.FSW is an RV32FC-only instruction that stores a single-precision floating-point value in floatingpoint register rs2 ′ to memory. It computes an effective address by adding the zero-extended offset, scaled by 4, to the base address in register rs1 ′. It expands to fsw rs2 ′, offset(rs1 ′).
    code: |
      offset = zero_extend(imm5) << 2
      mem[rs1' + offset] = rs2'
  C.FSD:
    require: [d]
    asm: c.fsd rs2', imm5(rs1')
    desc: C.FSD is an RV32DC/RV64DC-only instruction that stores a double-precision floating-point value in floating-point register rs2 ′ to memory. It computes an effective address by adding the zeroextended offset, scaled by 8, to the base address in register rs1 ′. It expands to fsd rs2 ′, offset(rs1 ′).
    code: |
      offset = zero_extend(imm5) << 3
      mem[rs1' + offset] = rs2'
  # Control Transfer Instructions
  C.J:
    asm: c.j imm11
    desc: C.J performs an unconditional control transfer. The offset is sign-extended and added to the pc to form the jump target address. C.J can therefore target a ±2 KiB range. C.J expands to jal x0, offset.
    code: |
      offset = sign_extend(imm11) << 1
      new_pc = current_pc + offset
  C.JAL:
    only_base: [RV32]
    asm: c.jal imm11
    desc: C.JAL is an RV32C-only instruction that performs the same operation as C.J, but additionally writes the address of the instruction following the jump (pc+2) to the link register, x1. C.JAL expands to jal x1, offset.
    code: |
      offset = sign_extend(imm11) << 1
      x1 = current_pc
      new_pc = current_pc + offset
  C.JR:
    asm: c.jr rs1
    desc: C.JR (jump register) performs an unconditional control transfer to the address in register rs1. C.JR expands to jalr x0, 0(rs1). C.JR is only valid when rs1̸=x0; the code point with rs1=x0 is reserved.
    code: |
      new_pc = rs1
  C.JALR:
    asm: c.jalr rs1
    desc: C.JALR (jump and link register) performs the same operation as C.JR, but additionally writes the address of the instruction following the jump (pc+2) to the link register, x1. C.JALR expands to jalr x1, 0(rs1). C.JALR is only valid when rs1̸=x0; the code point with rs1=x0 corresponds to the C.EBREAK instruction.
    code: |
      x1 = current_pc
      new_pc = rs1
  C.BEQZ:
    asm: c.beqz rs1', imm8
    desc: C.BEQZ performs conditional control transfers. The offset is sign-extended and added to the pc to form the branch target address. It can therefore target a ±256 B range. C.BEQZ takes the branch if the value in register rs1 ′ is zero. It expands to beq rs1 ′, x0, offset.
    code: |
      if rs1' == 0:
        offset = sign_extend(imm8) << 1
        new_pc = current_pc + offset
  C.BNEZ:
    asm: c.bnez rs1', imm8
    desc: C.BNEZ is defined analogously, but it takes the branch if rs1 ′ contains a nonzero value. It expands to bne rs1 ′, x0, offset.
    code: |
      if rs1' != 0:
        offset = signe_extend(imm8) << 1
        new_pc = current_pc + offset
  #Integer Constant-Generation Instructions
  C.LI:
    asm: c.li rd, imm6
    desc: C.LI loads the sign-extended 6-bit immediate, imm, into register rd. C.LI expands into addi rd, x0, imm. C.LI is only valid when rd̸=x0; the code points with rd=x0 encode HINTs.
    code: rd = sign_extend(imm6)
  C.LUI:
    asm: c.lui rd, nzimm6
    desc: C.LUI loads the non-zero 6-bit immediate field into bits 17–12 of the destination register, clears the bottom 12 bits, and sign-extends bit 17 into all higher bits of the destination. C.LUI expands into lui rd, nzimm. C.LUI is only valid when rd̸={x0, x2}, and when the immediate is not equal to zero. The code points with nzimm=0 are reserved; the remaining code points with rd=x0 are HINTs; and the remaining code points with rd=x2 correspond to the C.ADDI16SP instruction.
    code: |
      imm17 = nzimm6 << 12
      rd = sign_extend(imm17)
  # Integer Register-Immediate Operations
  C.ADDI:
    asm: c.addi rd, nzimm6
    desc: C.ADDI adds the non-zero sign-extended 6-bit immediate to the value in register rd then writes the result to rd. C.ADDI expands into addi rd, rd, nzimm. C.ADDI is only valid when rd̸=x0 and nzimm̸=0. The code points with rd=x0 encode the C.NOP instruction; the remaining code points with nzimm=0 encode HINTs.
    code: rd = rd + sign_extend(nzimm6)
  C.ADDIW:
    only_base: [RV64, RV128]
    asm: c.addiw rd, imm6
    desc: C.ADDIW is an RV64C/RV128C-only instruction that performs the same computation but produces a 32-bit result, then sign-extends result to 64 bits. C.ADDIW expands into addiw rd, rd, imm. The immediate can be zero for C.ADDIW, where this corresponds to sext.w rd. C.ADDIW is only valid when rd̸=x0; the code points with rd=x0 are reserved.
    code: |
      temp_32bit = rd_32bit + sign_textend(imm6)
      rd = sign_textend(temp_32bit)
  C.ADDI16SP:
    asm: c.addi16sp x2, imm6
    desc: C.ADDI16SP shares the opcode with C.LUI, but has a destination field of x2. C.ADDI16SP adds the non-zero sign-extended 6-bit immediate to the value in the stack pointer (sp=x2), where the immediate is scaled to represent multiples of 16 in the range (-512,496). C.ADDI16SP is used to adjust the stack pointer in procedure prologues and epilogues. It expands into addi x2, x2, nzimm. C.ADDI16SP is only valid when nzimm̸=0; the code point with nzimm=0 is reserved.
    code: x2 = x2 + sign_extend(imm6 << 4)
  C.ADDI4SPN:
    asm:  c.addi4spn rd', x2, nzuimm8
    desc: C.ADDI4SPN is a CIW-format instruction that adds a zero-extended non-zero immediate, scaled by 4, to the stack pointer, x2, and writes the result to rd ′. This instruction is used to generate pointers to stack-allocated variables, and expands to addi rd ′, x2, nzuimm. C.ADDI4SPN is only valid when nzuimm̸=0; the code points with nzuimm=0 are reserved.
    code: |
      rd' = x2 + zero_extend(nzuimm8 << 2)
  C.SLLI:
    asm: c.slli rd, shamt6
    desc: |
      C.SLLI is a CI-format instruction that performs a logical left shift of the value in register rd then writes the result to rd. The shift amount is encoded in the shamt field. For RV128C, a shift amount of zero is used to encode a shift of 64. C.SLLI expands into slli rd, rd, shamt, except for RV128C with shamt=0, which expands to slli rd, rd, 64.
      For RV32C, shamt[5] must be zero; the code points with shamt[5]=1 are designated for custom extensions. For RV32C and RV64C, the shift amount must be non-zero; the code points with shamt=0 are HINTs. For all base ISAs, the code points with rd=x0 are HINTs, except those with shamt[5]=1 in RV32C.
    code: rd = rd << shamt6
  C.SRLI:
    asm: c.srli rd, shamt6
    desc: |
      C.SRLI is a CB-format instruction that performs a logical right shift of the value in register rd ′ then writes the result to rd ′. The shift amount is encoded in the shamt field. For RV128C, a hift amount of zero is used to encode a shift of 64. Furthermore, the shift amount is sign-extended for RV128C, and so the legal shift amounts are 1–31, 64, and 96–127. C.SRLI expands into srli rd ′, d ′, shamt, except for RV128C with shamt=0, which expands to srli rd ′, rd ′, 64.
      For RV32C, shamt[5] must be zero; the code points with shamt[5]=1 are designated for custom extensions. For RV32C and RV64C, the shift amount must be non-zero; the code points with shamt=0 are HINTs.
    code: rd = rd >> shamt6
  C.SRAI:
    asm: c.srai rd, shamt6
    desc: C.SRAI is defined analogously to C.SRLI, but instead performs an arithmetic right shift. C.SRAI expands to srai rd ′, rd ′, shamt.
    code: rd = rd >>> shamt6
  C.ANDI:
    asm: c.andi rd', imm6
    desc: C.ANDI is a CB-format instruction that computes the bitwise AND of the value in register rd ′ and the sign-extended 6-bit immediate, then writes the result to rd ′. C.ANDI expands to andi rd ′, rd ′, imm.
    code: rd' = rd' & sign_extend(imm6)
  # Integer Register-Register Operations
  C.MV:
    asm: c.mv rd, rs2
    desc: C.MV copies the value in register rs2 into register rd. C.MV expands into add rd, x0, rs2. C.MV is only valid when rs2̸=x0; the code points with rs2=x0 correspond to the C.JR instruction. The code points with rs2̸=x0 and rd=x0 are HINTs.
    code: rd = rs2
  C.ADD:
    asm: c.add rd, rs2
    desc: C.ADD adds the values in registers rd and rs2 and writes the result to register rd. C.ADD expands into add rd, rd, rs2. C.ADD is only valid when rs2̸=x0; the code points with rs2=x0 correspond to the C.JALR and C.EBREAK instructions. The code points with rs2̸=x0 and rd=x0 are HINTs.
    code: rd = rd + rs2
  C.AND:
    asm: c.and rd', rs2'
    desc: C.AND computes the bitwise AND of the values in registers rd ′ and rs2 ′, then writes the result to register rd ′. C.AND expands into and rd ′, rd ′, rs2 ′.
    code: rd' = rd' and rs2' 
  C.OR:
    asm: c.or rd', rs2'
    desc: C.OR computes the bitwise OR of the values in registers rd ′ and rs2 ′, then writes the result to register rd ′. C.OR expands into or rd ′, rd ′, rs2 ′.
    code: rd' = rd' or rs2'
  C.XOR:
    asm: c.xor rd', rs2'
    desc: C.XOR computes the bitwise XOR of the values in registers rd ′ and rs2 ′, then writes the result to register rd ′. C.XOR expands into xor rd ′, rd ′, rs2 ′.
    code: rd' = rd' xor rs2'
  C.SUB:
    asm: c.sub rd', rs2'
    desc: C.SUB subtracts the value in register rs2 ′ from the value in register rd ′, then writes the result to register rd ′. C.SUB expands into sub rd ′, rd ′, rs2 ′.
    code: rd' = rd' - rs2'
  C.ADDW:
    only_base: [RV64, RV128]
    asm: c.addw rd', rs2'
    desc: C.ADDW is an RV64C/RV128C-only instruction that adds the values in registers rd ′ and rs2 ′, then sign-extends the lower 32 bits of the sum before writing the result to register rd ′. C.ADDW expands into addw rd ′, rd ′, rs2 ′.
    code: |
      temp_32bit = lower_32bit(rd') + lower_32bit(rs2')
      rd' = sign_extend(temp_32bit)
  C.SUBW:
    only_base: [RV64, RV128]
    asm: c.subw rd', rs2'
    desc: C.SUBW is an RV64C/RV128C-only instruction that subtracts the value in register rs2 ′ from the value in register rd ′, then sign-extends the lower 32 bits of the difference before writing the result to register rd ′. C.SUBW expands into subw rd ′, rd ′, rs2 ′.
    code: |
      temp_32bit = lower_32bit(rd') + lower_32bit(rs2')
      rd' = sign_extend(temp_32bit)

V:
  meta:
    version: "1.0"
    desc: "vector instructions"
